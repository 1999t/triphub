## TripHub 项目介绍

### 一、项目总体概览

- **项目定位**  
  TripHub 是一个面向个人用户的行程管理与旅游玩法 Demo 项目，涵盖：
  - 手机号验证码登录与用户鉴权；
  - 行程创建、按天编辑与缓存优化；
  - 热门行程 / 热门目的地榜单；
  - 限时秒杀旅游优惠（高并发下单链路）；
  - 用户画像与 AI 行程推荐（RAG 味道的轻量级实践）。

- **使用场景**  
  适合作为面试作品或学习项目，展示「登录鉴权 + 缓存 + 排行榜 + 秒杀 + AI 推荐」在一个统一业务域下的组合实现。

### 二、工程模块与目录结构

- **Maven 多模块工程**
  - `triphub-parent`：父工程，统一依赖版本与插件管理（JDK 17、Spring Boot、MyBatis-Plus、Redisson、RabbitMQ 等）。
  - `triphub-common`：通用基础组件：
    - 统一返回结果：`Result`、`PageResult`
    - 全局异常：`GlobalExceptionHandler`
    - JWT 配置与工具：`JwtProperties`、`JwtUtil`
    - 用户上下文：`BaseContext`
    - Redis / Redisson / RabbitMQ 基础配置：`RedisConfiguration`、`RedissonConfig`、`MqConfig`
    - Redis 相关常量：`RedisConstants`
  - `triphub-pojo`：实体、DTO、VO 定义：
    - 实体：`User`、`Trip`、`TripDay`、`TripItem`、`SeckillActivity`、`Order`、`UserProfile` 等
    - DTO / VO：行程按天编辑 DTO、AI 行程请求 DTO、AI 行程返回 VO、推荐行程 VO 等
  - `triphub-server`：业务服务模块：
    - Controller：用户登录、行程、发现页、秒杀、AI 等接口
    - Service / ServiceImpl：业务逻辑实现
    - Mapper：MyBatis-Plus 映射接口
    - Utils：`CacheClient`、`RedisIdWorker`、`AiClient` 等

- **数据库与初始化脚本**
  - 初始化脚本：`db/init_triphub.sql`
  - 核心表：
    - `user`：用户基础信息
    - `trip` / `trip_day` / `trip_item`：行程主表与按天拆分结构
    - `seckill_activity` / `order`：限时秒杀活动与订单
    - `user_profile`：用户画像 JSON 存储

### 三、核心业务功能概览

- **1. 用户认证与画像**
  - 支持手机号 + 验证码登录、JWT 鉴权与当前用户信息查询，保证后续所有接口都能识别「当前用户」。
  - 通过 `user_profile` 表与 `/user/profile` 接口管理用户画像，为 AI 行程规划与个性化推荐提供输入。

- **2. 行程管理与按天编辑**
  - 支持用户创建行程、查看详情、分页查看「我的行程」，并按「Trip / TripDay / TripItem」三层结构管理每天的行程条目。
  - 具体接口与请求示例集中在 `docs/trip/create_trip.md` 与 `docs/trip/day_edit.md` 中说明，本项目介绍不再逐一罗列增删改查 API。

- **3. 行程缓存与热门榜单**
  - 行程详情缓存：
    - 使用 `CacheClient.queryWithLogicalExpire` 实现逻辑过期 + 互斥锁重建，防止缓存击穿
    - 缓存 Key：`cache:trip:{id}`，结合逻辑过期时间与后台重建线程
  - 热门行程 / 热门目的地榜单：
    - 热门行程 ZSet：`hot:trip`，member 为 `tripId`，score 为浏览次数
    - 热门目的地 ZSet：`hot:dest`，member 为目的地城市名
    - 每次成功访问行程详情时，累加对应 ZSet 分数，用于驱动热门行程与热门目的地榜单。

- **4. 限时秒杀旅游优惠**
  - 活动配置与库存：
    - `seckill_activity` 表维护标题、地点、库存、时间窗口、状态等信息
    - Redis 预热库存：`seckill:stock:{activityId}`
  - Redis + Lua 预检：
    - Lua 脚本原子完成：
      - 库存校验（<=0 视为库存不足）
      - 一人一单（`seckill:order:{activityId}` Set 维护已下单用户），成功则扣减库存并写入用户 Set
  - 异步下单与幂等：
    - 使用 `RedisIdWorker` 生成全局订单 ID，通过 RabbitMQ 投递消息到 `TRIPHUB_EXCHANGE` / `TRIPHUB_SECKILL_QUEUE`
    - 消费端 `SeckillOrderListener` 使用 Redisson 分布式锁和数据库二次检查，确保一人一单与幂等

- **5. 用户画像 & AI 行程推荐**
  - 画像存储：
    - `user_profile.profile_json` 以 JSON 形式灵活存储标签、预算、时长偏好等，支持画像字段快速演进
  - AI 行程规划与推荐：
    - 基于用户画像与目的地参数，构造 Trip 草稿并调用 LLM 生成解释文案
    - 结合热门 ZSet 与画像标签，生成带「推荐理由」的个性化行程列表

### 四、工程级技术模块与亮点

- **1. 可观测性与监控模块**
  - **请求级 traceId 机制**：
    - 通过 `TraceLoggingFilter` 为每个 HTTP 请求生成或透传 `traceId`（Header：`X-Trace-Id`），并写入 MDC；
    - 在请求开始与结束时统一输出日志，包含：`traceId`、`userId`、HTTP 方法、URI、状态码与耗时，便于一条日志链路追踪完整调用。
  - **用户身份关联日志**：
    - `JwtTokenUserInterceptor` / `JwtTokenAdminInterceptor` 在完成 JWT 解析后，将当前用户/管理员 ID 写入 `BaseContext` 与 MDC（key=`userId`）；
    - 这样秒杀、AI 调用等后续业务日志均可自动带上 `traceId + userId` 组合，方便按用户维度排查问题。
  - **关键链路结构化日志**：
    - 在 AI 行程规划接口中，记录「开始 / 结束」两类日志，字段包括：`traceId`、`userId`、目的地、天数、画像主标签、生成行程 ID、是否成功拿到解释文案等；
    - 在秒杀服务中，对 Redis + Lua 预检结果（成功 / 库存不足 / 重复下单）、MQ 发送失败等场景输出结构化中文日志，用于快速判定故障点在「预检」还是「异步落单」。
  - **业务指标与 Micrometer 预留**：
    - 引入 `spring-boot-starter-actuator` 与统一的 `MetricsRecorder` 组件，使用 Micrometer 记录核心 Counter 指标，例如：
      - `triphub.trip.cache{outcome=hit|miss}`：行程详情缓存命中 / 未命中次数；
      - `triphub.hot_ranking.update{type=trip|dest}`：热门行程 / 热门目的地榜单分数更新次数；
      - `triphub.seckill.precheck{outcome=success|stock_not_enough|repeat_order}`：秒杀 Lua 预检成功、库存不足、一人一单被拦截的次数。
    - 当前指标默认使用内存 Registry，即使尚未接入 Prometheus 也不会影响业务；未来只需在配置中启用对应 Registry，即可将这些指标暴露到监控系统。
  - **异常场景强制打点规范**：
    - 通过注释与文档约定：JWT 解析失败、缓存重建异常、秒杀消息发送失败、AI 调用异常等场景必须打 ERROR/WARN 级日志，并携带 `traceId`、`userId`、关键业务参数；
    - 让项目在排查「缓存不命中原因」「热门榜单未更新」「秒杀成功但未落单」这类问题时，有足够的观测数据支撑分析。

- **2. 接口安全与限流模块**
  - **JWT 鉴权与资源级权限控制**：
    - 通过 `JwtTokenUserInterceptor` / `JwtTokenAdminInterceptor` 统一解析请求头中的 token，将用户/管理员 ID 写入 `BaseContext`，所有 `/user/**` 接口都依赖该上下文做登录态校验；
    - 在行程相关接口中（如 `/user/trip/day/detail`、`/user/trip/item` 系列），显式校验「当前用户是否为行程拥有者」，避免越权访问或非法修改他人行程数据。
  - **基于 Redis 的接口限流实现**：
    - 抽象出 `SimpleRateLimiter` 组件，使用「固定时间窗口 + 自增计数」方式做限流控制，键设计为 `rl:{bizKey}:{identify}`，不引入复杂算法，重点保证简单可靠；
    - 对验证码发送接口 `/user/auth/sendCode`：
      - 按 IP 维度：同一 IP 在 60 秒内最多请求 20 次；
      - 按手机号维度：同一手机号在 1 小时内最多请求 5 次；
      - 超出阈值统一返回 `code = 1`、`msg = "请求过于频繁，请稍后再试"`，有效防止脚本频繁打验证码接口。
    - 对秒杀下单接口 `/user/seckill/{activityId}`：
      - 按 IP + 活动维度：同一 IP 对同一活动 1 秒内最多 50 次请求；
      - 按用户 + 活动维度：同一用户对同一活动 1 秒内最多 10 次请求；
      - 在高并发压测或恶意攻击场景下，通过 Redis 限流将大部分无效流量挡在业务逻辑之前，保护后端 Redis / MQ / DB。
  - **安全异常的统一编码与文案**：
    - 在 `docs/developer/api_error_matrix.md` 中，对登录、受保护接口访问、秒杀和限流场景给出了统一的错误码与文案约定，例如：
      - 未登录或 token 无效 → `code = 1`，`msg = "未登录或 token 无效"`；
      - 越权访问行程 → `code = 1`，提示「行程不存在或无权访问」类文案；
      - 触发限流（验证码 / 秒杀） → `code = 1`，`msg = "请求过于频繁，请稍后再试"`。
    - 通过将这些约定前置到文档与实现中，保证安全相关返回在前后端协作和测试阶段都是可预期、可回归的。

- **3. 一致性与对账模块**
  - 秒杀链路采用「Redis 库存 + Lua 预检 + MQ 异步下单 + 数据库库存扣减」的最终一致性模型，避免在高并发下频繁锁表：
    - 入口 `/user/seckill/{activityId}` 调用 `SeckillServiceImpl.seckill`，使用内嵌 Lua 脚本在 Redis 中原子完成：
      - 读取 `seckill:stock:{activityId}`（String，表示当前剩余库存），若 `<=0` 直接返回库存不足；
      - 检查 `seckill:order:{activityId}`（Set，已成功下单用户 ID 集合）中是否已存在当前用户，命中则返回一人一单限制；
      - 通过后执行 `DECR seckill:stock:{activityId}` 并 `SADD seckill:order:{activityId} userId`，完成预扣库存与记录用户。
    - 预检成功后通过 `RedisIdWorker` 生成全局唯一 `orderId`，将 `{orderId,userId,activityId}` 投递到 MQ，消费者 `SeckillOrderListener`：
      - 先根据 `lock:seckill:order:{userId}` 获取 Redisson 分布式锁，保证同一用户消息串行处理；
      - 再次查询 `order` 表校验是否已存在相同 `userId + seckillActivityId` 的记录，确保一人一单与幂等；
      - 插入订单记录并执行 `seckill_activity.stock = stock - 1` 的更新语句，使数据库库存与 Redis 预扣库存最终收敛一致。
  - 定期对账由 `ConsistencyReconciliationTask.checkSeckillConsistency` 负责（基于 Spring `@Scheduled` 周期任务）：
    - 周期性遍历在线的 `seckill_activity` 活动（`status = 1`），对每个活动读取：
      - Redis：`seckill:stock:{id}` 当前剩余库存、`seckill:order:{id}` Set 中已下单用户数量；
      - DB：`seckill_activity.stock` 字段值、`order` 表中 `seckill_activity_id = id` 的订单数量；
    - 若发现「Redis 库存 vs DB 库存」「Redis 一人一单集合大小 vs DB 订单条数」存在不一致，统一输出结构化英文 WARN 日志，详细记录 `activityId`、`redisStock`、`dbStock`、`redisOrderSize`、`dbOrderCount`，便于挂监控告警；
    - 同时引入一个**自动补偿策略**：仅在「DB 领先 Redis」时触发补偿（例如 Redis Key 丢失、Redis 库存大于 DB 库存、Redis 一人一单集合比 DB 订单数少），通过 `rebuildSeckillCacheFromDb` 用 DB 作为单一事实源重建 `seckill:stock` / `seckill:order`，实现 Redis 层的自愈；整个过程只写 Redis，不回写 DB，避免对核心交易真相表做侵入性修改。
  - 热门榜单的自愈由同一组件中的 `ConsistencyReconciliationTask.rebuildHotRankingFromDb` 实现：
    - 每小时定时从数据库中按 `view_count` 倒序查询固定数量的公开行程（`visibility = 2`），作为「权威热度源」；
    - 先清空 Redis 中的 `hot:trip`、`hot:dest` ZSet，再按以下规则重建：
      - `hot:trip`：member 为 `tripId`，score 直接使用行程的 `view_count`；
      - `hot:dest`：member 为目的地城市名 `destinationCity`，score 为该城市下所有热门行程 `view_count` 的累加（若 view_count 为空则至少加 1）；
    - 这样当 Redis 数据丢失或被运维清空时，只需等待定时任务跑一次，即可从 DB 自动恢复「热门行程 / 热门目的地」榜单，体现 Redis 作为缓存层的「可重建、自愈」意识，而不会影响核心真相数据仍然留存在 MySQL。

- **4. 测试与质量保障模块**
  - 项目内提供完整的 Postman 集合 `triphub-auth.postman_collection.json`，覆盖登录、行程管理、按天编辑、热门榜单、秒杀、用户画像、AI 推荐等所有核心接口，并通过 Tests 脚本自动写入 `userToken`、`tripId`、`tripItemId`、`seckillOrderId` 等变量，形成一套「接口链路自动串联」的端到端测试流。
  - 在 `docs/` 目录下按模块拆分接口说明与测试步骤（auth / trip / discover / seckill / ai），与 Postman 用例一一对应，组成结构化的手工测试用例库：既可以单独按模块做手工验证，也可以配合 Postman 集合跑一整套从「登录 → 行程创建与按天编辑 → 热门榜单 → 秒杀下单 → 画像与 AI 推荐」的完整链路回归。
  - 在代码层面，已经为缓存组件 `CacheClient`、全局 ID 生成器 `RedisIdWorker` 与核心秒杀服务 `SeckillServiceImpl` 编写了 JUnit5 + Mockito 的基础单元测试：覆盖缓存命中与空值缓存、防止缓存穿透的逻辑，以及秒杀未登录/活动不可用/Lua 预检成功等关键分支，保证这些高风险基础组件有最基本的保护网。
  - 作为后续演进方向，计划在现有单测基础上继续补充基于 SpringBootTest + Testcontainers 的端到端集成测试（例如拉起 MySQL / Redis / RabbitMQ 的容器环境，真实走一次「Redis 预检 → MQ 投递 → 消费端落单与扣减库存」链路），进一步提升自动化回归与整体质量保障能力。

- **5. 工程化与部署支持模块**
  - 配置管理：
    - 使用 `application.yml` + `application-dev.yml` + `application-prod.yml` 配合 `spring.profiles.active` 管理多环境配置；
    - 将 **数据库、Redis、RabbitMQ 地址与账号、AI Key** 等敏感信息统一抽象为环境变量（如 `TRIPHUB_DB_URL`、`TRIPHUB_REDIS_HOST`、`TRIPHUB_MQ_HOST`、`TRIPHUB_AI_API_KEY` 等），代码中只读取占位符，避免在仓库中硬编码。
  - 初始化与运维脚本：提供 `db/init_triphub.sql` 与 `script/init_seckill.sh`，一键完成核心库表与秒杀活动、库存初始化，降低环境搭建成本。
  - 容器化与可上云形态：
    - 为 `triphub-server` 编写了简单的 `Dockerfile`，以打包后的 JAR 为入口，通过环境变量注入 DB / Redis / MQ / AI Key，并在 `ENTRYPOINT` 中内置 JDK17 所需的 `--add-opens` 启动参数；
    - 在仓库根目录提供 `docker-compose.yml`，一次性拉起 **MySQL + Redis + RabbitMQ + TripHub 应用** 四个容器，并挂载 `db/init_triphub.sql` 自动建库建表；
    - 实际体验是：从拉代码到 `docker-compose up --build` 起一整套本地环境 **小于 5 分钟**，更接近真实可部署的线上服务而不是只能在 IDE 里跑的 Demo。
  - CI/CD 雏形：
    - 预留基于 GitHub Actions / GitLab CI 的简单流水线设计：`mvn test` → `mvn -pl triphub-server -am package` → 基于 `triphub-server/Dockerfile` 构建镜像并推送到镜像仓库；
    - 面试时可以说明：当前项目已经按这种流水线拆好了步骤，后续只需在 CI 平台上写少量 YAML，就能接入真正的自动化构建与发布。

### 五、技术栈与关键实现点

- **基础技术栈**
  - JDK 17、Spring Boot、Spring MVC
  - MyBatis-Plus（简化 CRUD 与分页）
  - MySQL（业务数据持久化）
  - Redis（缓存、ZSet 排行榜、秒杀库存与一人一单状态）
  - RabbitMQ（秒杀异步下单）
  - Redisson（分布式锁）
  - JWT（用户端鉴权）

- **缓存与高并发相关技术点**
  - 逻辑过期缓存：
    - 使用 `RedisData` 包装真实数据与逻辑过期时间
    - 到期后由后台线程异步重建，前端仍可读到旧数据
  - 缓存穿透防护：
    - 对不存在的数据写入空值缓存并设置较短 TTL
  - 排行榜实现：
    - 基于 Redis ZSet 实现热门行程与热门目的地榜单
  - 全局唯一 ID：
    - `RedisIdWorker`：时间戳 + Redis 自增序列，保证全局有序且不冲突
  - 秒杀链路：
    - Redis + Lua 预检 + 一人一单
    - MQ 异步下单 + Redisson 锁保证消费端幂等

- **AI 集成与 RAG 味道实践**
  - 可配置的 AI 调用参数：
    - `application.yml` 中通过 `triphub.ai.*` 配置 base-url、api-key、model 等
  - Prompt 设计：
    - 将用户画像 JSON、目的地、天数等拼接为提示词
    - 要求大模型输出纯中文解释文本
  - 降级策略：
    - 外部 LLM 不可用时，本地拼接一段说明文案，保证接口始终返回成功结果（只是在解释字段上有差异）

### 六、文档与测试入口说明

- **开发与架构文档**
  - `docs/developer/architecture_overview.md`：整体架构与核心流程
  - `docs/developer/api_error_matrix.md`：核心接口异常场景与预期行为

- **模块化接口与测试文档（按业务模块划分）**
  - 认证与用户：
    - `docs/auth/login.md`：验证码发送、登录、当前用户信息接口说明与测试步骤
    - `docs/auth/user_profile_and_rag_like_recommendation.md`：用户画像与 AI 推荐整体设计、接口说明及演示脚本
  - 行程相关：
    - `docs/trip/create_trip.md`：行程创建、详情（含缓存）、我的行程列表
    - `docs/trip/day_edit.md`：TripDay / TripItem 按天编辑全流程
    - `docs/trip/trip_cache.md`：行程缓存与逻辑过期、ZSet 重建等说明
  - 发现与榜单：
    - `docs/discover/hot_ranking.md`：热门行程 / 热门目的地榜单接口及 Redis ZSet 验证
  - 秒杀模块：
    - `docs/seckill/init_env.md`：秒杀环境初始化与一键重置脚本说明
    - `docs/seckill/lua_validate.md`：Lua 预检脚本逻辑与 Redis 验证方法
    - `docs/seckill/mq_process.md`：秒杀异步下单与 MQ 消费链路
    - `docs/seckill/load_test.md`：秒杀压测方案与数据一致性校验

- **使用建议**
  - 新同学建议阅读顺序：
    1. `项目介绍.md`（本文，了解整体功能与技术点）
    2. `TripHub代码开发规划.md`（代码规范与开发约定）
    3. `docs/developer/architecture_overview.md`
    4. 按需查阅 `docs/auth/*`、`docs/trip/*`、`docs/discover/*`、`docs/seckill/*` 完成接口测试。

### 七、配置、部署与工程化：更像一个“可上云”的服务

- **多环境配置与敏感信息管理**
  - 通过 `application.yml` 统一声明应用名、端口、通用 Jackson/MVC 配置，并设置 `spring.profiles.active=${SPRING_PROFILES_ACTIVE:dev}` 作为入口；
  - 使用 `application-dev.yml` / `application-prod.yml` 拆分数据库、Redis、RabbitMQ 等环境相关配置：开发环境提供本地默认值；生产环境强制从环境变量（如 `TRIPHUB_DB_URL`、`TRIPHUB_DB_USERNAME`、`TRIPHUB_DB_PASSWORD`）读取，避免明文写死；
  - AI 相关配置（`triphub.ai.base-url`、`api-key`、`model`）统一走环境变量占位符，例如 `TRIPHUB_AI_API_KEY`，方便在不同云厂商或模型服务之间切换。

- **容器化与一键起服务**
  - `triphub-server/Dockerfile` 基于 JDK17 运行时镜像，直接复制 Maven 打包后的 JAR，使用环境变量注入 `SPRING_PROFILES_ACTIVE`、DB / Redis / MQ 地址与凭证，并在 `JAVA_OPTS` 中内置 `--add-opens java.base/java.lang.invoke=ALL-UNNAMED` 以兼容 MyBatis-Plus 在 JDK17 上的反射访问；
  - 根目录的 `docker-compose.yml` 定义了四个核心服务：
    - `mysql`：挂载 `db/init_triphub.sql` 到 `/docker-entrypoint-initdb.d/`，容器首次启动时自动建库建表；
    - `redis`：用于缓存、热门榜单、秒杀库存与一人一单状态；
    - `rabbitmq`：管理秒杀异步下单的交换机与队列；
    - `triphub-server`：依赖上述三者，通过环境变量对接各自的地址与账号；
  - 本地只需要一条命令：`docker-compose up --build`，即可从源码构建镜像并一键起完整链路，适合作为“可上云 Demo 项目”的工程化展示。

- **CI/CD 面试话术示例**
  - 可以这样向面试官描述当前的工程化设计：
    > 我把配置按 dev / prod 拆开，用 `spring.profiles.active` 控制生效环境，数据库、Redis、MQ 地址和 AI Key 都通过环境变量注入，仓库里不放任何明文凭证。  
    > 应用支持打成 Docker 镜像，并通过 docker-compose 一次性拉起 MySQL、Redis、RabbitMQ 和 TripHub 服务，从拉代码到本地完整链路跑通在 5 分钟之内。  
    > 此外，我预留了基于 GitHub Actions / GitLab CI 的流水线设计：先 `mvn test` 做单测，再 `mvn package` 打包，最后基于 Dockerfile 构建并推送镜像，这样稍加配置就能接入真正的 CI/CD 平台。


