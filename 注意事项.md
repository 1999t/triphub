## TripHub 开发注意事项记录

### 1. JDK 版本与编译问题

- **问题现象**
  - 使用系统默认的较新 JDK（例如 25）时，IDEA 编译出现类似：
    - `java: source value 8 is obsolete and will be removed in a future release`
    - `java.lang.ExceptionInInitializerError`、`TypeTag :: UNKNOWN` 等异常。
- **原因分析**
  - Spring Boot 2.7 + MyBatis-Plus + Lombok 等依赖，对特别新的 JDK 支持不够稳定；
  - 项目 `pom.xml` 中设置的 `java.version` 仍然是 1.8，和高版本 JDK 组合使用容易触发编译器内部兼容问题。
- **解决方案**
  - 将项目统一切换到 **JDK 17**：
    - IDEA 中设置 `Project SDK = 17`，各模块 Language Level 使用 SDK 默认或 17。
    - 在父 POM `triphub/pom.xml` 中：
      - 将 `<java.version>` 设置为 `17`；
      - `<maven.compiler.source>` 和 `<maven.compiler.target>` 使用 `${java.version}`。
  - 确保安装并启用 Lombok 插件，并在 IDEA 中开启 Annotation Processing。
- **经验总结**
  - 对于 Spring Boot 2.x 项目，**优先使用 LTS 版本的 JDK（11 或 17）**，不要直接用最新的实验性版本。
  - `pom.xml` 中的 `java.version` 要与实际使用的 JDK 一致，避免编译期奇怪错误。

### 2. Knife4j / Springfox 与 Spring Boot 2.7 的兼容问题

- **问题现象**
  - 应用启动阶段报错并退出，日志中包含：
    - `Failed to start bean 'documentationPluginsBootstrapper'`
    - `Caused by: java.lang.NullPointerException: Cannot invoke "PatternsRequestCondition.getPatterns()" because "this.condition" is null`
  - 控制台最后有 `Application run failed` 和 `Process finished with exit code 1`。
- **原因分析**
  - Springfox 3.0.0 与 Spring Boot 2.6+ 默认启用的 `PathPatternParser` 路径匹配策略存在兼容性问题；
  - 需要将 Spring MVC 的路径匹配策略切回旧版 `AntPathMatcher`。
- **解决方案**
  - 在 `triphub-server/src/main/resources/application.yml` 增加以下配置：
    ```yaml
    spring:
      mvc:
        pathmatch:
          matching-strategy: ant_path_matcher
    ```
  - 重启应用后，Knife4j / Springfox 能正常初始化文档插件，服务可正常启动。
- **经验总结**
  - 使用 Springfox 3.x + Spring Boot 2.6+ 时，如果出现 `documentationPluginsBootstrapper` 相关 NPE，**优先检查 `spring.mvc.pathmatch.matching-strategy` 配置**。
  - 观察启动日志时：
    - 有 `Application run failed` + 异常栈 + `exit code 1` → 启动失败；
    - 有 `Tomcat started on port(s): xxxx (http)` 且进程不退出 → 启动成功。

### 3. MyBatis-Plus 注解依赖缺失导致 pojo 模块编译错误

- **问题现象**
  - `triphub-pojo` 编译失败，但 `triphub-server` 编译正常。
  - 控制台报错信息指向 `com.baomidou.mybatisplus.annotation.*` 找不到类（或类似符号无法解析）。
- **原因分析**
  - `User` 等实体类上使用了 MyBatis-Plus 的注解（例如 `@TableName`、`@TableId`），但这些实体所在的模块是 `triphub-pojo`；
  - 原来只在 `triphub-server` 中引入了 `mybatis-plus-boot-starter`，而 `triphub-pojo` 本身没有依赖 `mybatis-plus-annotation`，编译期自然找不到注解类。
- **解决方案**
  - 在父 POM `triphub/pom.xml` 的 `<dependencyManagement>` 中添加：
    ```xml
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-annotation</artifactId>
        <version>${mybatis.plus.version}</version>
    </dependency>
    ```
  - 在 `triphub-pojo/pom.xml` 中为实体模块显式引入注解依赖：
    ```xml
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-annotation</artifactId>
    </dependency>
    ```
  - 在 IDEA 中重新 Reload Maven Project，然后 Rebuild。
- **经验总结**
  - **哪一层模块里写了注解，就要在哪一层模块里引入对应依赖**，不要只依赖「上层业务模块」；
  - entity 通常放在独立的 pojo/dao 模块时，要记得为该模块准备 ORM 注解相关依赖。

### 4. Postman Collection 导入失败（JSON 格式问题）

- **问题现象**
  - 导入 `triphub-auth.postman_collection.json` 时，Postman 提示：
    - `We don’t recognize/support this format.`
- **原因分析**
  - 手动编辑 Collection JSON 时混入了 diff 符号（例如行首的 `+`），导致文件不再是合法 JSON；
  - Postman 只能识别严格符合 schema 的 JSON，不会容忍这种格式错误。
- **解决方案**
  - 确保 `.json` 文件中不存在任何 diff 标记（如行首的 `+`、`-` 等），只保留标准 JSON 内容；
  - 必要时可将 JSON 粘贴到在线 JSON 校验工具检查格式是否正确；
  - 修正后重新在 Postman 中使用 `Import -> File` 导入即可。
- **经验总结**
  - 从对话或 diff 中拷贝 JSON 时，要特别小心去除所有补丁标记符号；
  - 对于要导入第三方工具的配置文件（Postman、Swagger 等），**先本地做一次 JSON 格式校验**是个好习惯。

### 5. Redisson / Redis 未启动导致应用启动失败

- **问题现象**
  - 应用启动日志中报错：
    - `Error creating bean with name 'redissonClient' ... Unable to connect to Redis server: localhost/127.0.0.1:6379`
    - 最终 `Application run failed`，进程退出。
- **原因分析**
  - 在 `RedissonConfig` 中创建 `RedissonClient` 时，默认连接地址为 `redis://localhost:6379`；
  - 本机没有启动 Redis 服务，或者 Redis 端口/地址与配置不一致，导致 Redisson 在初始化连接时抛出 `RedisConnectionException`；
  - 因为这是一个必须创建的 Bean，连接失败会直接导致 Spring 容器启动失败。
- **解决方案（推荐）**
  - 在本机启动 Redis 服务，并确保端口与配置一致：
    - macOS 示例（使用 Homebrew）：
      ```bash
      brew install redis          # 如果尚未安装
      brew services start redis   # 后台启动 Redis，默认端口 6379
      ```
    - 或者使用其他方式启动 Redis，只要保证可以连接 `localhost:6379` 即可。
  - 如需连接远程 Redis，可在 `application.yml` 中调整：
    ```yaml
    spring:
      redis:
        host: your-redis-host
        port: 6379
    ```
    同时 `RedissonConfig` 会读取 `spring.redis.host/port` 自动拼接地址。
- **可选临时方案（开发阶段）**
  - 如果暂时不想依赖 Redis/Redisson，也可以为 `RedissonConfig` 增加条件开关，例如：
    ```java
    @Configuration
    @ConditionalOnProperty(prefix = "triphub.redisson", name = "enabled", havingValue = "true")
    public class RedissonConfig { ... }
    ```
    并在 `application.yml` 中设置：
    ```yaml
    triphub:
      redisson:
        enabled: false
    ```
    这样在本地未开启 Redis 时也能启动应用，只是所有依赖 Redisson 的功能（分布式锁等）会不可用。
- **经验总结**
  - 只要在配置中声明了「强依赖外部服务」的 Bean（如 Redis、MQ、ES），**应用启动前要么先把服务拉起来，要么提供显式的开关/降级路径**；
  - 日志中出现 `Unable to connect to Redis server`、`Connection refused` 等字样时，优先检查服务有没有启动、地址和端口是否匹配。 

### 6. 未初始化数据库/建表脚本导致 MyBatisSystemException

- **问题现象**
  - 用户登录接口 `/user/auth/login` 调用时报错，控制台出现：
    - `MyBatisSystemException: nested exception is ... Error evaluating expression 'ew.sqlSegment ...'`
    - 日志中由 `UserServiceImpl.loginByPhone` 引发，并最终被 `GlobalExceptionHandler` 包装为「系统异常，请稍后重试」。
- **原因分析**
  - MyBatis-Plus 在执行 `lambdaQuery().eq(User::getPhone, phone).one()` 时，会构造 SQL 访问 `triphub.user` 表；
  - 如果数据库或表尚未创建（例如没有执行建库建表脚本），底层抛出的 SQL 异常会在 OGNL 表达式解析阶段被包裹成 `BuilderException` / `OgnlException`，最终表现为 `MyBatisSystemException`，信息较难直接看出是“表不存在”；
  - 本质问题仍然是：**数据库 schema 未初始化**。
- **解决方案**
  - 在项目仓库中准备统一的初始化脚本（本项目为 `db/init_triphub.sql`），内容包括：
    - 创建数据库 `triphub`；
    - 创建与实体类对应的表（当前至少包括 `user` 表）。
  - 使用 Docker 启动 MySQL 时，可以这样挂载初始化脚本：
    ```bash
    docker run -d \
      --name mysql-triphub \
      -e MYSQL_ROOT_PASSWORD=123456 \
      -e MYSQL_DATABASE=triphub \
      -p 3306:3306 \
      -v /Users/AryaTan/workspace/workspace0/triphub/db/init_triphub.sql:/docker-entrypoint-initdb.d/init_triphub.sql \
      mysql:8.0
    ```
    - 容器第一次启动时会自动执行挂载到 `/docker-entrypoint-initdb.d/` 下的脚本，完成建库建表。
  - 确保 `application.yml` 中配置的 `spring.datasource.url` 与容器暴露的地址、库名一致，例如 `jdbc:mysql://localhost:3306/triphub?...`。
- **经验总结**
  - 使用 MyBatis-Plus 时，若看到 `MyBatisSystemException` + `BuilderException` + `ew.sqlSegment` 之类的信息，**优先排查表是否存在、字段是否匹配**；
  - 在项目中维护一份可重复执行的初始化 SQL（并在 Docker 中自动执行），比手动在本地一次次建表更稳定、也更方便团队协作和环境重建。 

### 7. JDK 17 + MyBatis-Plus LambdaQuery 触发 InaccessibleObjectException

- **问题现象**
  - 调用 `lambdaQuery().eq(User::getPhone, phone).one()` 时，控制台出现较长的异常栈，最内层包含：
    - `Caused by: java.lang.reflect.InaccessibleObjectException: Unable to make field private final java.lang.Class java.lang.invoke.SerializedLambda.capturingClass accessible: module java.base does not "opens java.lang.invoke" to unnamed module`
  - 外层表现为：
    - `MyBatisSystemException`
    - `BuilderException: Error evaluating expression 'ew.sqlSegment != null ...'`
    - `OgnlException: sqlSegment [java.lang.ExceptionInInitializerError]`
- **原因分析**
  - MyBatis-Plus 3.4.3 在处理 Lambda 表达式（例如 `User::getPhone`）时，会通过反射访问 JDK 的内部类 `java.lang.invoke.SerializedLambda` 的私有字段；
  - JDK 17 引入了更严格的模块封装，默认不允许未命名模块反射访问 `java.base/java.lang.invoke` 包中的私有字段，从而抛出 `InaccessibleObjectException`；
  - 这在 JDK 8 中是允许的，因此同一版本 MyBatis-Plus 在 JDK 8 正常、在 JDK 17 需要额外配置。
- **解决方案（开发环境）**
  - 在 IDEA 的运行配置中为 `TriphubServerApplication` 添加 VM 选项：
    ```text
    --add-opens java.base/java.lang.invoke=ALL-UNNAMED
    ```
    操作路径：
    - Run → Edit Configurations… → 选择 `TriphubServerApplication`
    - 在 “VM options” 输入框中填入上述参数并保存；
    - 重新运行应用后，LambdaQuery 将正常工作。
- **解决方案（打包运行 / 生产环境）**
  - 使用命令行启动 jar 时，在 `java` 命令中加入同样的 `--add-opens` 参数，例如：
    ```bash
    java --add-opens java.base/java.lang.invoke=ALL-UNNAMED -jar triphub-server.jar
    ```
  - 若使用 Docker，可在镜像的启动脚本或 `ENTRYPOINT` 中加入该 JVM 参数。
- **可选改进**
  - 升级 MyBatis-Plus 至更高版本（例如 3.5.x 系列），官方在新版本中对 JDK 9+ 反射访问做了适配，可以减少对 `--add-opens` 的依赖；
  - 升级前需同步评估与 Spring Boot 2.7 的兼容性。
- **经验总结**
  - 从 JDK 9 开始，很多基于“反射黑科技”的框架在访问 JDK 内部类/字段时都需要显式 `--add-opens` 或升级版本以适配新的模块系统；
  - 遇到 `InaccessibleObjectException` 这类错误时，应优先查看**是哪个模块在访问 JDK 内部包**，再决定是通过 JVM 参数开放模块，还是升级相关依赖库。 

### 8. JJWT 0.9.1 在 JDK 17 上缺失 JAXB 导致 NoClassDefFoundError

- **问题现象**
  - 用户登录接口调用时抛出：
    - `java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter`
  - 栈信息指向：
    - `io.jsonwebtoken.impl.Base64Codec.decode`
    - `io.jsonwebtoken.impl.DefaultJwtBuilder.signWith`
    - `com.triphub.common.utils.JwtUtil.createJWT`
  - 最外层由 Spring 包装为 `NestedServletException: Handler dispatch failed`，被全局异常处理器捕获为「系统异常」。
- **原因分析**
  - 当前使用的 JJWT 版本为 `0.9.1`，内部依赖 `javax.xml.bind.DatatypeConverter` 做 Base64 处理；
  - 在 JDK 8 中，JAXB（`javax.xml.bind`）是 JDK 自带模块，但从 JDK 11 起已从 JDK 中移除，需要由应用自行引入依赖；
  - 在未引入 JAXB 依赖的情况下，运行到 JJWT 时就会出现 `NoClassDefFoundError: javax/xml/bind/DatatypeConverter`。
- **解决方案**
  - 在 `triphub-common/pom.xml` 中为 JJWT 补充 JAXB 依赖：
    ```xml
    <dependency>
        <groupId>javax.xml.bind</groupId>
        <artifactId>jaxb-api</artifactId>
        <version>2.3.1</version>
    </dependency>
    <dependency>
        <groupId>org.glassfish.jaxb</groupId>
        <artifactId>jaxb-runtime</artifactId>
        <version>2.3.1</version>
    </dependency>
    ```
  - Reload Maven Project 并重新启动应用后，JWT 生成逻辑可在 JDK 17 上正常运行。
- **可选改进**
  - 后续可以考虑升级到 JJWT 0.11.x 版本，改用 `jjwt-api` / `jjwt-impl` / `jjwt-jackson` 的分模块结构，减少对旧版 JAXB 的依赖；
  - 升级时需要按官方文档调整依赖和 `signWith` 的用法。
- **经验总结**
  - 许多老版本库（尤其是依赖 `javax.xml.bind`、`javax.activation` 等 JDK8 自带模块的）在 JDK 11+ 上运行时，都需要显式引入对应的独立依赖；
  - 当看到 `NoClassDefFoundError: javax/...` 这一类错误时，应优先判断：**是不是 JDK 把某些模块移出标准库导致，需要在项目中单独引入依赖**。 

### 9. 未预热缓存时直接使用逻辑过期策略导致「数据不存在」

- **问题现象**
  - 已通过 `POST /user/trip` 创建若干行程，`GET /user/trip/list` 能正确返回列表和各行程的 ID；
  - 但调用 `GET /user/trip/{id}`（详情接口）时，却返回：
    ```json
    { "code": 1, "msg": "行程不存在" }
    ```
  - Redis 中对应的 `cache:trip:{id}` 键在首次访问前是不存在的。
- **原因分析**
  - 详情接口使用了 `CacheClient.queryWithLogicalExpire` 做缓存读取：
    ```java
    Trip trip = cacheClient.queryWithLogicalExpire(
        CACHE_TRIP_KEY, id, Trip.class, this::getById, ...
    );
    ```
  - 逻辑过期方案在黑马点评的原始设计中，**默认前提是热点数据已预热到 Redis**（即 key 一定存在，只是可能过期），当 key 不存在时直接返回 null；
  - 在本项目中，创建行程时并未给 Redis 预热 `cache:trip:{id}`，导致首次查询时：
    - 读取 Redis 返回 `null`；
    - 旧实现中直接 `return null`，没有回源 DB，最终被 Controller 认为「行程不存在」。
- **解决方案**
  - 修正 `queryWithLogicalExpire` 的逻辑，在缓存 miss 时兜底访问 DB 并写入逻辑过期缓存：
    ```java
    String json = stringRedisTemplate.opsForValue().get(key);
    // 1. 缓存不存在：兜底走一次 DB，再写入逻辑过期缓存
    if (!StringUtils.hasText(json)) {
        R dbResult = dbFallback.apply(id);
        if (dbResult == null) {
            return null;
        }
        setWithLogicalExpire(key, dbResult, time, unit);
        return dbResult;
    }
    // 2. 缓存存在：反序列化并判断逻辑过期时间
    ```
  - 这样既保留了逻辑过期 + 异步重建的优势，又能在未预热场景下保证「首次请求一定能回源 DB」。
- **经验总结**
  - 逻辑过期策略通常假设「热点数据已预热」，若直接用于所有普通业务数据，必须在缓存 miss 时做回源兜底，否则会出现「明明 DB 有数据，但接口说不存在」的错误；
  - 一般实践是：
    - 普通数据 → 用 **Cache Aside + 穿透防护**（queryWithPassThrough）；
    - 极少数热点数据 → 结合预热 + 逻辑过期（queryWithLogicalExpire）。 

### 10. RabbitMQ 未启动导致 AmqpConnectException（Connection refused）

- **问题现象**
  - 应用启动日志中出现类似信息：
    - `Attempting to connect to: [localhost:5672]`
    - `Broker not available; cannot force queue declarations during start: java.net.ConnectException: Connection refused`
    - `org.springframework.amqp.AmqpConnectException: java.net.ConnectException: Connection refused`
  - `TriphubServerApplication` 依然能正常启动（Tomcat 已监听 8090 端口），但后台日志中 `SimpleMessageListenerContainer` 持续输出「Consumer raised exception」「Restarting Consumer...」。
- **原因分析**
  - 项目中已经启用了 RabbitMQ 相关配置与监听器（`MqConfig` + `SeckillOrderListener`），`spring-boot-starter-amqp` 会在启动时尝试连接 RabbitMQ；
  - 配置默认连接地址为 `localhost:5672`，但本机并没有启动 RabbitMQ 服务，或者端口不匹配；
  - 结果是：业务 HTTP 接口可以工作，但所有依赖 MQ 的功能（比如秒杀异步下单）实际处于「不断重连失败」状态。
- **解决方案（推荐）**
  - **本地开发时确保先启动 RabbitMQ**：
    - Docker 示例：
      ```bash
      docker run -d \
        --name rabbitmq-triphub \
        -p 5672:5672 \
        -p 15672:15672 \
        -e RABBITMQ_DEFAULT_USER=guest \
        -e RABBITMQ_DEFAULT_PASS=guest \
        rabbitmq:3-management
      ```
      然后在浏览器打开 `http://localhost:15672`，确认 MQ 已正常运行。
    - 若使用本地安装的 RabbitMQ，确保服务已启动，监听 `localhost:5672`。
  - **如需连接远程 MQ**：在 `application.yml` 中显式配置：
    ```yaml
    spring:
      rabbitmq:
        host: your-rabbit-host
        port: 5672
        username: your-user
        password: your-pass
    ```
    并确保 `MqConfig` 中使用的交换机、队列名称与服务端配置一致。
- **可选临时方案（开发阶段关闭 MQ 功能）**
  - 如果当前阶段只想调试非 MQ 相关接口，可以在配置中暂时关闭监听容器的自动启动，例如：
    ```yaml
    spring:
      rabbitmq:
        listener:
          simple:
            auto-startup: false
    ```
    这样监听端不会在启动时去连 MQ，但所有依赖 MQ 的异步功能（例如秒杀下单消费）将会失效，仅用于本地调试其他模块。
- **经验总结**
  - 只要在项目中引入了 RabbitMQ、Kafka、Redis 等中间件并配置了监听容器，就要么**保证对应服务已经启动并可连通**，要么提供显式的配置开关关闭这些监听；
  - 日志中连续出现 `AmqpConnectException: Connection refused`、`Restarting Consumer` 之类信息，说明 MQ 连接存在问题，应优先检查服务是否启动、地址端口与账号密码是否正确。 

### 11. 秒杀库存为什么要同步到 Redis，以及如何自动初始化

- **问题现象**
  - 在 MySQL 中已经为 `seckill_activity` 配置了 `stock`，并且 `status = 1`、时间窗口也正确；
  - 但直接调用 `POST /user/seckill/{activityId}` 时，接口返回：
    ```json
    { "code": 1, "msg": "Seckill stock is not enough", "data": null }
    ```
  - 使用 Redis CLI 查看：
    ```shell
    GET seckill:stock:{activityId}
    ```
    返回 `nil` 或不存在该 key。
- **原因分析**
  - 秒杀扣减库存的逻辑是**完全基于 Redis** 的 Lua 脚本：
    - MySQL 中的 `seckill_activity.stock` 只是活动配置，不参与高并发扣减；
    - 真正用于扣减的库存在 Redis 中，key：`seckill:stock:{activityId}`；
    - 如果该 key 不存在或值为 0，Lua 脚本会直接认为「库存不足」，返回错误码 `1`，从而在接口层表现为 `"Seckill stock is not enough"`。
  - 也就是说：
    - 「插入活动记录」只是在 MySQL 里建了一条配置；
    - 如果不额外初始化 Redis 的 `seckill:stock`，业务层面就永远认为库存为 0。
- **早期做法：必须手动设置 Redis 库存**
  - 典型步骤是：
    ```shell
    SET seckill:stock:1 50
    ```
  - 很多第一次做秒杀的人都会踩这个坑：以为有了 DB 的 `stock` 字段，接口就能用，结果忘记给 Redis 预热库存。
- **当前改进：应用启动时自动初始化库存**
  - 为了避免每次都手动 `SET`，项目中在 `SeckillActivityServiceImpl` 中增加了启动初始化逻辑：
    ```java
    @PostConstruct
    public void loadSeckillStock() {
        List<SeckillActivity> activities = this.lambdaQuery()
                .eq(SeckillActivity::getStatus, 1)
                .gt(SeckillActivity::getStock, 0)
                .list();
        if (activities == null || activities.isEmpty()) {
            return;
        }
        for (SeckillActivity activity : activities) {
            Long id = activity.getId();
            if (id == null) {
                continue;
            }
            String key = RedisConstants.SECKILL_STOCK_KEY + id;
            String stockStr = String.valueOf(activity.getStock());
            Boolean set = stringRedisTemplate.opsForValue().setIfAbsent(key, stockStr);
            // 如果 Redis 中没有该 key，则写入初始库存；已有则保留现有值
        }
    }
    ```
  - 启动应用时，会自动：
    - 查出所有 `status = 1` 且 `stock > 0` 的秒杀活动；
    - 对每个活动执行一次 `SETNX seckill:stock:{id} {stock}`：
      - 如果 key 不存在 → 使用 DB 中的库存初始化；
      - 如果 key 已存在（例如你在 Redis 手工调过） → 保留已有值，不覆盖。
- **经验总结**
  - 对于「高并发依赖缓存」的业务（如秒杀），要明确区分：
    - MySQL 中的配置字段（如 `stock`）更多是「源数据」；
    - 实际运行时读写的是 Redis 中的一组 key；
  - 如果仅仅改 DB 不更新 Redis，**多数情况下业务行为不会跟着变**；
  - 最安全的实践：
    - 提供统一的「缓存预热/同步机制」，例如本项目中的 `loadSeckillStock`；
    - 更新 DB 配置后，要么重启应用触发自动同步，要么提供后台管理接口专门刷新对应 Redis key。 


