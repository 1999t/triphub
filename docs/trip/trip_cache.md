## 行程缓存与缓存重建说明

> 说明 Trip 详情缓存的读写策略、缓存重建流程，以及与 Redis 故障时的行为。

### 1. 缓存键设计与命中路径

- **键前缀**
  - `CACHE_TRIP_KEY = "cache:trip:" + tripId`

- **读流程（`GET /user/trip/{id}`）**
  1. 根据 `tripId` 拼接 Redis Key。
  2. 先从 Redis 读取 JSON：
     - 命中：
       - 解析逻辑过期时间：
         - 未过期：直接返回缓存数据；
         - 已过期：返回旧数据的同时异步触发缓存重建线程。
     - 未命中：
       - 回源数据库 `trip` 表；
       - 查到数据 → 写入逻辑过期缓存；
       - 未查到数据 → 可选择写入短 TTL 的空值防止穿透。

### 2. 缓存重建策略

- **逻辑过期时间选择**
  - 普通行程：推荐 30 分钟～2 小时；
  - 明显热点行程（访问量很高）：可以缩短为 5～15 分钟，配合异步重建。

- **重建触发条件**
  - 逻辑过期时间已过；
  - 只有拿到互斥锁的一条线程负责真正重建，其他线程直接返回旧数据。

- **重建步骤概览**
  1. 拿 Redis 分布式锁，Key 形如：`lock:trip:{{tripId}}`；
  2. 再次检查缓存是否已被其他线程重建；
  3. 查询 DB 最新 Trip 数据；
  4. 以新的逻辑过期时间写回 Redis；
  5. 释放锁。

### 3. Redis 清空后的修复流程

- **场景**：运维误删 `cache:trip:*` 或清空 Redis。

- **修复方式（接口侧自动兜底）**
  - 缓存 miss 时，不直接返回「行程不存在」，而是：
    1. 兜底回源 DB 查询；
    2. 查到数据 → 立即重新写入逻辑过期缓存；
    3. 未查到数据 → 视为真的不存在，可写入短 TTL 的空对象。

- **运维/排查建议**
  - 清理缓存后，随机访问几条典型行程详情，观察是否能自动恢复；
  - 配合 Redis `KEYS cache:trip:*` 或 `SCAN` 命令确认缓存已逐步恢复。

### 4. 热门榜单 ZSet 重建

- **键设计**
  - 行程热门榜：`HOT_TRIP_ZSET = "hot:trip"`
  - 目的地热门榜：`HOT_DEST_ZSET = "hot:dest"`

- **重建思路**
  - 若 Redis ZSet 意外丢失，可通过 DB 或日志重建：
    1. 统计一段时间内行程被访问次数（可通过日志/埋点统计）；
    2. 扫描 `trip` 表，对近 30 天有访问记录的行程，用 `ZINCRBY hot:trip <viewCount> <tripId>` 重新写入；
    3. 根据各行程 `destinationCity` 聚合，使用 `ZINCRBY hot:dest <cityViewCount> <cityName>` 重建目的地榜单。
  - 对于当前 Demo 实现，可以在压测或手动访问后，让应用端按请求路径自然重建榜单。

### 5. Redis 崩溃与容灾策略

- **Redis 暂时不可用时**
  - 读流程：
    - 访问缓存失败时直接回源 DB；
    - 可以在日志中打出 ERROR 级别「Redis unavailable, fallback to DB」。
  - 写流程：
    - 后台异步重建线程应对 Redis 异常有容错，避免无限重试；
    - 暂停缓存重建，待 Redis 恢复后再继续。

- **建议的运维策略**
  - 为 Redis 配置持久化（RDB+AOF）与主从复制，避免单点故障；
  - 在 README 或本文件中记录一次「Redis 故障演练」的操作步骤：
    1. 人为停止 Redis；
    2. 验证核心查询接口能否退化到 DB 而不是直接 500；
    3. 重启 Redis 后，观察缓存和 ZSet 是否能在访问过程中逐步恢复。


