## TripHub 项目进度与测试计划

### 文档结构与模块化索引

- **测试与说明文档目录（docs）**
  - `docs/auth/login.md`：登录与当前用户接口测试。
  - `docs/trip/create_trip.md`：行程创建与基础查询。
  - `docs/trip/day_edit.md`：TripDay / TripItem 按天编辑。
  - `docs/trip/trip_cache.md`：行程缓存与缓存重建策略。
  - `docs/discover/hot_ranking.md`：热门行程 / 目的地榜单。
  - `docs/seckill/init_env.md`：秒杀环境初始化与一键重置。
  - `docs/seckill/lua_validate.md`：Lua 预检脚本逻辑与校验。
  - `docs/seckill/mq_process.md`：秒杀异步下单与 MQ 消费流程。
  - `docs/seckill/load_test.md`：秒杀压测方案。
  - `docs/developer/architecture_overview.md`：整体架构与核心流程说明。
  - `docs/developer/api_error_matrix.md`：核心 API 异常场景测试表。

- **使用建议**
  - 本文件侧重进度概览和总览级说明，具体接口测试步骤优先参考 `docs/` 下对应模块化文档。

### 一、当前开发进度概览

- **工程骨架**
  - 已搭建 Maven 多模块工程：`triphub-parent` + `triphub-common` + `triphub-pojo` + `triphub-server`。
  - JDK 版本统一为 **17**，父 POM 已配置 `java.version=17`，依赖已适配 JDK 17（含 MyBatis-Plus、JJWT + JAXB、Redisson 等）。
  - 基础设施已完成：
    - 全局返回封装：`Result`、`PageResult`
    - 全局异常处理：`GlobalExceptionHandler`
    - JWT 配置 + 工具：`JwtProperties`、`JwtUtil`
    - 用户上下文：`BaseContext`
    - Redis 配置：`RedisConfiguration`
    - Redisson 配置：`RedissonConfig`
    - RabbitMQ 基本配置：`MqConfig`
    - WebMvc + JWT 拦截器注册：`WebMvcConfiguration` + `JwtTokenUserInterceptor` / `JwtTokenAdminInterceptor`
    - 缓存客户端：`CacheClient`（支持穿透防护、逻辑过期 + 互斥锁重建）

- **数据库与实体**
  - 已提供初始化脚本：`db/init_triphub.sql`，包含：
    - `triphub` 库
    - `user` 表（与 `com.triphub.pojo.entity.User` 对应）
    - `trip` / `trip_day` / `trip_item` 三张行程相关表。
  - 实体已完成：
    - `User`、`Trip`、`TripDay`、`TripItem`

- **已实现功能模块**
  - 用户登录与鉴权（用户端）：
    - `POST /user/auth/sendCode`：模拟发送验证码（固定返回 `"1234"`）
    - `POST /user/auth/login`：手机号 + 验证码登录，返回 JWT token
  - 当前用户信息：
    - `GET /user/profile/me`：基于 JWT + `BaseContext` 返回当前登录用户信息
  - 行程管理与缓存（简版）：
    - `POST /user/trip`：创建行程（只保存 Trip 主信息）
    - `GET /user/trip/{id}`：行程详情（使用 `CacheClient.queryWithLogicalExpire` 做缓存）
    - `GET /user/trip/list`：当前用户行程分页列表

### 二、接口测试计划（Postman）

> 对应 Postman 集合文件：`triphub/triphub-auth.postman_collection.json`

#### 1. 用户登录相关接口

- **用户-发送验证码** `POST /user/auth/sendCode`
  - 请求：
    - URL：`{{baseUrl}}/user/auth/sendCode`
    - Header：`Content-Type: application/json`
    - Body(JSON)：
      ```json
      { "phone": "{{phone}}", "code": "" }
      ```
  - 预期结果：
    - HTTP 状态码：`200`
    - Body：
      ```json
      { "code": 0, "msg": "ok", "data": "1234" }
      ```

- **用户-登录** `POST /user/auth/login`
  - 请求：
    - URL：`{{baseUrl}}/user/auth/login`
    - Header：`Content-Type: application/json`
    - Body(JSON)：
      ```json
      { "phone": "{{phone}}", "code": "1234" }
      ```
  - 预期结果：
    - HTTP 状态码：`200`
    - Body 中：
      - `code = 0`
      - `data` 为一串 JWT 字符串（非空）
    - Postman Tests 脚本会自动把 `data` 写入集合变量 `userToken`。

#### 2. 当前用户信息接口

- **用户-当前信息** `GET /user/profile/me`
  - 请求：
    - URL：`{{baseUrl}}/user/profile/me`
    - Header：
      - `token: {{userToken}}`
  - 预期结果：
    - 已登录（`userToken` 合法）：
      ```json
      {
        "code": 0,
        "msg": "ok",
        "data": {
          "id": <Long>,
          "phone": "{{phone}}",
          "...": "其他字段可能为 null 或默认值"
        }
      }
      ```
    - 未携带或携带无效 token：
      - `code = 1`，`msg = "未登录或 token 无效"`。

#### 3. 行程接口（创建 / 查询 / 列表）

- **行程-创建** `POST /user/trip`
  - 请求：
    - URL：`{{baseUrl}}/user/trip`
    - Header：
      - `Content-Type: application/json`
      - `token: {{userToken}}`
    - Body(JSON 示例)：
      ```json
      {
        "title": "成都三日美食行",
        "destinationCity": "成都",
        "startDate": "2025-12-20",
        "endDate": "2025-12-22",
        "days": 3,
        "visibility": 2
      }
      ```
  - 预期结果：
    - HTTP 状态码：`200`
    - Body：
      ```json
      { "code": 0, "msg": "ok", "data": <新建行程ID> }
      ```
    - 记录下返回的 `data` 作为后续 `/user/trip/{id}` 测试用的 `tripId`。

- **行程-详情（带缓存）** `GET /user/trip/{id}`
  - 请求：
    - URL：`{{baseUrl}}/user/trip/{{tripId}}`
    - Header：
      - `token: {{userToken}}`
  - 预期结果：
    - 第一次请求：命中数据库，Redis 中写入 `cache:trip:{{tripId}}`，Body：
      ```json
      {
        "code": 0,
        "msg": "ok",
        "data": {
          "id": {{tripId}},
          "title": "成都三日美食行",
          "destinationCity": "成都",
          ...
        }
      }
      ```
    - 多次重复请求：命中缓存，返回同样的数据，接口响应时间明显缩短（可通过 Postman 中的响应时间或配合 Redis CLI 观察）。

- **行程-我的列表** `GET /user/trip/list`
  - 请求：
    - URL：`{{baseUrl}}/user/trip/list?page=1&size=10`
    - Header：
      - `token: {{userToken}}`
  - 预期结果：
    - Body：
      ```json
      {
        "code": 0,
        "msg": "ok",
        "data": {
          "total": <总行程数>,
          "records": [
            { "id": ..., "title": "...", ... },
            ...
          ]
        }
      }
      ```

### 三、行程按天编辑接口（TripDay / TripItem）

> 依赖前置步骤：已完成登录、获取 `userToken`，并通过「行程-创建」接口拿到 `tripId`。

#### 1. 按天查看行程详情 `GET /user/trip/day/detail`

- **请求**
  - URL：`{{baseUrl}}/user/trip/day/detail?tripId={{tripId}}&dayIndex=1`
  - Header：
    - `token: {{userToken}}`
- **预期结果**
  - HTTP 状态码：`200`
  - 第一次访问某天且未创建任何条目时：
    ```json
    {
      "code": 0,
      "msg": "ok",
      "data": {
        "id": null,
        "tripId": {{tripId}},
        "dayIndex": 1,
        "note": null,
        "items": []
      }
    }
    ```

#### 2. 设置行程日备注 `PUT /user/trip/day/note`

- **请求**
  - URL：`{{baseUrl}}/user/trip/day/note`
  - Header：
    - `Content-Type: application/json`
    - `token: {{userToken}}`
  - Body(JSON)：
    ```json
    {
      "tripId": {{tripId}},
      "dayIndex": 1,
      "note": "第一天主要逛春熙路、宽窄巷子"
    }
    ```
- **预期结果**
  - HTTP 状态码：`200`
  - Body：`{ "code": 0, "msg": "ok", "data": null }`
  - 再次调用「按天查看行程详情」，`data.note` 字段更新为上述文案。

#### 3. 新增行程条目 `POST /user/trip/item`

- **请求**
  - URL：`{{baseUrl}}/user/trip/item`
  - Header：
    - `Content-Type: application/json`
    - `token: {{userToken}}`
  - Body(JSON 示例)：
    ```json
    {
      "tripId": {{tripId}},
      "dayIndex": 1,
      "type": "FOOD",
      "placeId": 1,
      "startTime": "10:00:00",
      "endTime": "12:00:00",
      "memo": "春熙路小吃打卡"
    }
    ```
- **预期结果**
  - HTTP 状态码：`200`
  - Body：
    ```json
    { "code": 0, "msg": "ok", "data": <新建条目ID> }
    ```
  - 记录返回的 `data` 作为后续更新 / 删除条目的 `tripItemId`。

#### 4. 更新行程条目 `PUT /user/trip/item`

- **请求**
  - URL：`{{baseUrl}}/user/trip/item`
  - Header：
    - `Content-Type: application/json`
    - `token: {{userToken}}`
  - Body(JSON 示例)：
    ```json
    {
      "id": {{tripItemId}},
      "type": "FOOD",
      "placeId": 1,
      "startTime": "10:30:00",
      "endTime": "12:30:00",
      "memo": "调整为晚些出发"
    }
    ```
- **预期结果**
  - HTTP 状态码：`200`
  - Body：`{ "code": 0, "msg": "ok", "data": null }`
  - 再次调用「按天查看行程详情」，对应条目的时间和备注更新。

#### 5. 删除行程条目 `DELETE /user/trip/item/{id}`

- **请求**
  - URL：`{{baseUrl}}/user/trip/item/{{tripItemId}}`
  - Header：
    - `token: {{userToken}}`
- **预期结果**
  - HTTP 状态码：`200`
  - Body：`{ "code": 0, "msg": "ok", "data": null }`
  - 再次调用「按天查看行程详情」，`items` 数组长度减少，对应条目被删除。

### 四、热门行程 / 热门目的地榜单接口

#### 1. 热门行程列表 `GET /user/discover/hot-trips`

- **准备**
  - 通过多次访问「行程-详情」接口 `/user/trip/{{tripId}}`，触发行程浏览量累加，并写入 Redis ZSet：`hot:trip`。
  - 可以在 Redis CLI 中使用：
    ```shell
    ZREVRANGE hot:trip 0 10 WITHSCORES
    ```
    查看榜单内的行程 ID 及其分数（浏览量）。
- **请求**
  - URL：`{{baseUrl}}/user/discover/hot-trips?limit=10`
  - Header：
    - `token: {{userToken}}`
- **预期结果**
  - HTTP 状态码：`200`
  - Body：
    ```json
    {
      "code": 0,
      "msg": "ok",
      "data": [
        {
          "id": {{tripId}},
          "title": "成都三日美食行",
          "visibility": 2,
          "viewCount": ...,
          "likeCount": ...
        },
        ...
      ]
    }
    ```
  - 访问次数越多的行程排在越前，仅返回公开行程（`visibility = 2`）。

#### 2. 热门目的地列表 `GET /user/discover/hot-destinations`

- **准备**
  - 多个行程可以设置相同的 `destinationCity`，例如「成都」。
  - 通过访问不同行程详情接口 `/user/trip/{{tripId}}`，会同时累积：
    - 行程层面的 ZSet：`hot:trip`（member=tripId）
    - 目的地层面的 ZSet：`hot:dest`（member=destinationCity）
  - 可在 Redis CLI 中通过：
    ```shell
    ZREVRANGE hot:dest 0 10 WITHSCORES
    ```
    查看目的地城市及其热度分数（累计浏览次数）。
- **请求**
  - URL：`{{baseUrl}}/user/discover/hot-destinations?limit=10`
  - Header：
    - `token: {{userToken}}`
- **预期结果**
  - HTTP 状态码：`200`
  - Body：
    ```json
    {
      "code": 0,
      "msg": "ok",
      "data": [
        "成都",
        "北京",
        "上海"
      ]
    }
    ```
  - 返回按热度排序的目的地城市名称列表，前面的是被访问次数更多的目的地。

### 五、限时秒杀旅游优惠接口

> 当前实现为后端秒杀下单流程：Lua + Redis 预检、一人一单、库存扣减，全局 ID + RabbitMQ 异步下单，Redisson 分布式锁保证消费端幂等性。

#### 1. 准备数据（初始化秒杀活动与库存）

- 在 MySQL 中插入一条秒杀活动记录（示例）：
  ```sql
  INSERT INTO seckill_activity (title, place_id, stock, begin_time, end_time, status)
  VALUES ('成都酒店秒杀', 1, 50, NOW(), DATE_ADD(NOW(), INTERVAL 1 DAY), 1);
  ```
- 假设返回的主键为 `activityId = 1`。
- 在 Redis 中预热库存（示例）：
  ```shell
  SET seckill:stock:1 50
  ```

#### 2. 用户发起秒杀下单 `POST /user/seckill/{activityId}`

- **请求**
  - URL：`{{baseUrl}}/user/seckill/1`
  - Header：
    - `token: {{userToken}}`
- **预期结果**
  - HTTP 状态码：`200`
  - 抢购成功（库存充足且用户第一次参与）：
    ```json
    {
      "code": 0,
      "msg": "ok",
      "data": <全局订单ID>
    }
    ```
  - 库存不足：
    ```json
    { "code": 1, "msg": "Seckill stock is not enough", "data": null }
    ```
  - 重复下单（同一用户同一活动再请求）：
    ```json
    { "code": 1, "msg": "User has already placed an order for this activity", "data": null }
    ```

#### 3. Redis 预检与一人一单校验

- Lua 脚本逻辑（在服务端内嵌）：
  - 库存 Key：`seckill:stock:{activityId}`。
  - 下单用户集合 Key：`seckill:order:{activityId}`（Set，member=userId）。
  - 脚本步骤：
    1. 读取库存，小于等于 0 则返回 `1`（库存不足）。
    2. 使用 `SISMEMBER` 判断用户是否已在集合中，存在则返回 `2`（一人一单）。
    3. 使用 `DECR` 扣减库存，并将用户 ID 写入 Set，返回 `0`（成功）。
- 可在 Redis CLI 中观察：
  ```shell
  GET seckill:stock:1
  SMEMBERS seckill:order:1
  ```

#### 4. 异步下单与幂等消费

- 接口返回的 `orderId` 由 `RedisIdWorker` 生成，全局唯一。
- 成功通过 Lua 预检后，服务端会向 RabbitMQ 发送消息：
  - 交换机：`TRIPHUB_EXCHANGE`
  - 路由键：`seckill`
  - 队列：`TRIPHUB_SECKILL_QUEUE`
- 消费端 `SeckillOrderListener` 逻辑：
  - 使用 Redisson 分布式锁 `lock:seckill:order:{userId}`，保证同一用户并发消息只会被处理一次。
  - 再次通过数据库查询 `order` 表，确保不存在重复订单（幂等）。
  - 写入 `order` 表，并使用乐观方式扣减 `seckill_activity.stock`。
- 可在数据库中检验结果：
  ```sql
  SELECT * FROM `order` WHERE seckill_activity_id = 1;
  SELECT stock FROM seckill_activity WHERE id = 1;
  ```

#### 5. 单用户完整功能验证步骤（Postman 手动测试）

> 前置：已按前文完成「用户登录相关接口」的测试，拿到合法的 `{{userToken}}`。

1. **启动依赖组件**
   - 启动本地或 Docker 中的 MySQL、Redis、RabbitMQ。
   - 确认 `application.yml` 中的数据库、Redis、MQ 连接配置与本地环境一致。
2. **初始化秒杀活动与库存**
   - 在 MySQL 中执行本节「1. 准备数据」中的 `INSERT INTO seckill_activity ...` 语句。
   - 使用 `SELECT * FROM seckill_activity;` 确认活动已写入，`id` 为 `1`、`stock=50`。
   - 在 Redis CLI 中执行 `SET seckill:stock:1 50`，并通过 `GET seckill:stock:1` 校验。
3. **用 Postman 执行一次正常秒杀**
   - 在 Postman 中选择「秒杀-下单 /user/seckill/{activityId}」请求。
   - 确认 Header 中携带：`token: {{userToken}}`。
   - 点击 Send，预期响应 `code = 0`，`data` 为非空长整型订单 ID。
4. **验证 Redis 状态**
   - 使用 Redis CLI 查看库存与下单用户集合：
     ```shell
     GET seckill:stock:1
     SMEMBERS seckill:order:1
     ```
   - 预期：
     - `seckill:stock:1` 从 `50` 变为 `49`。
     - `seckill:order:1` 集合中包含当前用户的 `userId`。
5. **验证数据库落单结果**
   - 在 MySQL 中执行：
     ```sql
     SELECT * FROM `order` WHERE seckill_activity_id = 1;
     SELECT stock FROM seckill_activity WHERE id = 1;
     ```
   - 预期：
     - `order` 表中新增一条记录，`user_id` 为当前用户 ID，`id` 等于接口返回的 `orderId`。
     - `seckill_activity.stock` 已从 50 降为 49（若监听消费稍有延迟，可稍等几秒再查）。
6. **验证一人一单约束**
   - 对同一用户再次在 Postman 中调用 `POST /user/seckill/1`。
   - 预期响应：`code = 1`，`msg = "User has already placed an order for this activity"`。
   - 再次检查 Redis：`SMEMBERS seckill:order:1` 中用户 ID 不会重复出现；`GET seckill:stock:1` 不再减少。
   - 再次检查数据库：`order` 表中仅有一条该用户 + 活动的记录。
7. **验证库存不足场景（可选）**
   - 将 Redis 库存手工改小，例如：
     ```shell
     SET seckill:stock:1 0
     ```
   - 用任意已登录用户调用 `POST /user/seckill/1`。
   - 预期响应：`code = 1`，`msg = "Seckill stock is not enough"`；DB 中不新增订单记录。

#### 6. 多用户与并发验证步骤（JMeter / 多 Postman 实例，可选）

1. **准备多个用户账号**
   - 在用户表中插入多条手机号记录，或者复用当前登录流程，为不同手机号分别获取 `userToken`。
   - 在 Postman 中为每个用户配置一个环境或使用 JMeter 将 `token` 作为参数传入。
2. **并发请求模拟**
   - 方案一（简易）：在多个 Postman 实例里同时点击「秒杀-下单」。
   - 方案二（推荐）：使用 JMeter：
     - 创建 Thread Group，线程数设置为略大于库存（如 100），Ramp-Up 时间较短（如 1 秒）。
     - 使用 HTTP Request 组件配置 `POST /user/seckill/1`，Header 中设置 `token`（可简单先用同一个 token 验证「一人一单」）。
3. **并发结果预期**
   - 秒杀成功的响应数量不超过 `seckill:stock:1` 的初始值（例如 50）。
   - 同一个用户最多只成功一次，其余返回「User has already placed an order for this activity」。
   - Redis：
     - `GET seckill:stock:1` 的最终值 ≈ 初始库存 - 成功订单数。
     - `SCARD seckill:order:1`（集合大小）≈ 成功用户数（每个用户仅计一次）。
   - 数据库：
     - `SELECT COUNT(*) FROM \`order\` WHERE seckill_activity_id = 1;` 与成功响应次数一致。
     - 任意 `user_id` + `seckill_activity_id` 组合在表中最多出现一次。

### 六、后续测试计划占位

- 打卡签到 / UV 统计（Bitmap + HyperLogLog）

> 上述功能实现后，可在本文件持续追加对应接口、测试步骤与预期结果。


